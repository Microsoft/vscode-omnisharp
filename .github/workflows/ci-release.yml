name: OmniSharp-VSCode CI Release

on:
  workflow_run:
    workflows: ["OmniSharp-VSCode CI"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      tags:
        description: 'Run this manually'
        required: false
        type: boolean

jobs:
  release:
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repo
      uses: actions/checkout@v3

    - name: Find Latest Successful CI Run
      id: find-ci-run
      uses: actions/github-script@v6
      with:
        script: |
          const runs = await github.rest.actions.listWorkflowRuns({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: "ci.yml",
            status: "success",
            per_page: 1
          });
          if (runs.data.workflow_runs.length === 0) {
            throw new Error("No successful workflow runs found");
          }
          return runs.data.workflow_runs[0].id;

    - name: Set Workflow Run ID
      run: echo "WORKFLOW_RUN_ID=${{ steps.find-ci-run.outputs.result }}" >> $GITHUB_ENV

    # - name: Download all build artifacts
    #   uses: actions/download-artifact@v4
    #   with:
    #     path: ./vsix-release
    #     merge-multiple: true
    #     run-id: ${{ env.WORKFLOW_RUN_ID }}
    #     github-token: ${{ secrets.GITHUB_TOKEN }}

    - name: Download all build artifacts
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const runId = process.env.WORKFLOW_RUN_ID;
          const outputPath = './vsix-release';

          async function downloadArtifact(url, dest) {
            core.notice(`Downloading ${url} to ${dest}`)
            const response = await fetch(url, {
              headers: {
                Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
              }
            });
            if (!response.ok) throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
            const fileStream = fs.createWriteStream(dest);
            return new Promise((resolve, reject) => {
              response.body.pipe(fileStream);
              response.body.on('error', reject);
              fileStream.on('finish', resolve);
            });
          }

          async function main() {
            const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            if (!fs.existsSync(outputPath)) {
              fs.mkdirSync(outputPath, { recursive: true });
            }

            for (const artifact of artifacts.artifacts) {
              core.notice(`Getting redirect URL for artifact ${artifact.id} ${artifact.name}`)
              const result = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id,
                archive_format: 'zip',
              });
              core.notice(`Got result ${result}`)
              core.notice(result)

              const zipPath = path.join(outputPath, `${artifact.name}.zip`);
              await downloadArtifact(result.url, zipPath);
            }
          }

          main().catch(error => {
            core.setFailed(error.message);
          });
      env:
        WORKFLOW_RUN_ID: ${{ env.WORKFLOW_RUN_ID }}

    - name: Display structure of downloaded files
      run: |
        ls -R ./vsix-release

    - name: Get package version
      run: node -e "console.log('VERSION=' + require('./package.json').version)" >> $GITHUB_ENV

    - name: Create GitHub Release
      id: create_release
      uses: actions/github-script@v6
      continue-on-error: true
      with:
        script: |
          try {
            const response = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${process.env.VERSION}`,
              name: `Release ${process.env.VERSION}`,
              draft: false,
              prerelease: false,
            });
            core.setOutput('upload_url', response.data.upload_url);
          } catch (error) {
            if (error.status === 422 && error.message.includes('already_exists')) {
              console.log('Release already exists. Retrieving existing release upload URL.');
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              const existingRelease = releases.data.find(release => release.tag_name === `v${process.env.VERSION}`);
              if (existingRelease) {
                core.setOutput('upload_url', existingRelease.upload_url);
              } else {
                throw new Error('Release exists but could not find it.');
              }
            } else {
              throw error;
            }
          }

    - name: Upload release builds
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const releasesPath = path.join(process.env.GITHUB_WORKSPACE, 'vsix-release')

          const releasePlatforms = [
            'darwin-x64', 'linux-x64', 'win32-x64',
            //'platform-neutral'
          ]
          const artifacts = releasePlatforms.map(
            platform => ({
              path: path.join(releasesPath, `csharp-${platform}.vsix`),
              name: `csharp-${platform}-${process.env.VERSION}.vsix`
            })
          )

          for (const artifact of artifacts) {
            if (fs.existsSync(artifact.path)) {
              console.log(`Uploading ${artifact.name}...`);
              github.rest.repos.uploadReleaseAsset({
                url: '${{ steps.create_release.outputs.upload_url }}',
                headers: {
                  'content-type': 'application/zip',
                  'content-length': fs.statSync(artifact.path).size
                },
                name: artifact.name,
                data: fs.readFileSync(artifact.path)
              }).then(response => {
                console.log(`Uploaded ${artifact.name}`);
              }).catch(error => {
                console.error(`Failed to upload ${artifact.name}: ${error}`);
              });
            } else {
              console.log(`File ${artifact.path} does not exist. Skipping upload.`);
            }
          }